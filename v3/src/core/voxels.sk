enum Cell {
  EMPTY

  DIRT
  JUMP
  ROCK
  WATER
}

class TraceResult {
  var cellX = 0
  var cellY = 0
  var cellZ = 0

  var normalX = 0
  var normalY = 0
  var normalZ = 0

  var distance = 0.0
}

class Voxels {
  const _context GPU.Context
  const _pool GPU.BufferPool
  var _chunkMap IntMap<Chunk> = {}
  var _chunkList List<Chunk> = []

  def isEmptyForCollision(xmin int, ymin int, zmin int, xmax int, ymax int, zmax int) bool {
    for z = zmin; z <= zmax; z++ {
      for y = ymin; y <= ymax; y++ {
        for x = xmin; x <= xmax; x++ {
          const cell = get(x, y, z)
          if cell != .EMPTY && cell != .WATER {
            return false
          }
        }
      }
    }

    return true
  }

  def get(x int, y int, z int) Cell {
    var chunk = _chunkMap.get(_key(x, y, z), null)
    return chunk == null ? .EMPTY : chunk.get(x & CELLS_MASK, y & CELLS_MASK, z & CELLS_MASK)
  }

  def set(x int, y int, z int, cell Cell) {
    var key = _key(x, y, z)
    var map = _chunkMap
    var chunk = map.get(key, null)

    if chunk == null && cell != .EMPTY && _isValid(x, y, z) {
      chunk = Chunk.new(x & ~CELLS_MASK, y & ~CELLS_MASK, z & ~CELLS_MASK)
      map[key] = chunk
      _chunkList.append(chunk)
    }

    chunk?.set(x & CELLS_MASK, y & CELLS_MASK, z & CELLS_MASK, cell)
  }

  def draw(material GPU.Material, eye Vector3, orientation Matrix) {
    for chunk in _chunkList {
      chunk.distanceToEye = _temp.setTo(chunk.centerX, chunk.centerY, chunk.centerZ).subtract(eye).lengthSquared
    }

    # Sort chunks front-to-back to take maximal advantage of high-z. This uses
    # insertion sort instead of the JavaScript sort() function to avoid allocation
    # and to speed up the common case of the list being already sorted.
    const count = _chunkList.count
    for i in 1..count {
      const x = _chunkList[i]
      var j = i - 1
      while j >= 0 && _chunkList[j].distanceToEye > x.distanceToEye {
        _chunkList[j + 1] = _chunkList[j]
        j--
      }
      _chunkList[j + 1] = x
    }

    # The distance from the chunk center to a chunk corner
    const CORNER_DISTANCE = CELLS_SIZE * 0.5 * Math.sqrt(3)

    const eyeDistance =
      orientation.m20 * eye.x +
      orientation.m21 * eye.y +
      orientation.m22 * eye.z

    for chunk in _chunkList {
      const lookDistance =
        orientation.m20 * chunk.centerX +
        orientation.m21 * chunk.centerY +
        orientation.m22 * chunk.centerZ

      # Cull chunks behind the camera
      if lookDistance - CORNER_DISTANCE > eyeDistance {
        continue
      }

      _context.draw(.TRIANGLES, material,
        lookDistance + CORNER_DISTANCE + App.DISSOLVE_DISTANCE < eyeDistance ? chunk.sparseArea(_pool) : chunk.denseArea(_pool),
        .CULL_BACK_FACES)
    }
  }

  def draw(lines Lines) {
    for chunk in _chunkList {
      lines.appendCube(
        chunk.originX,
        chunk.originY,
        chunk.originZ,
        chunk.originX + CELLS_SIZE,
        chunk.originY + CELLS_SIZE,
        chunk.originZ + CELLS_SIZE,
        .WHITE)
    }
  }

  def trace(x double, y double, z double, rayX double, rayY double, rayZ double, result TraceResult) bool {
    var cellX = result.cellX = Math.floor(x) as int
    var cellY = result.cellY = Math.floor(y) as int
    var cellZ = result.cellZ = Math.floor(z) as int

    result.normalX = 0
    result.normalY = 0
    result.normalZ = 0

    const floorX = (cellX - x) / rayX
    const floorY = (cellY - y) / rayY
    const floorZ = (cellZ - z) / rayZ

    const ceilX = (cellX + 1 - x) / rayX
    const ceilY = (cellY + 1 - y) / rayY
    const ceilZ = (cellZ + 1 - z) / rayZ

    const stepX = rayX > 0 ? 1 : rayX < 0 ? -1 : 0
    const stepY = rayY > 0 ? 1 : rayY < 0 ? -1 : 0
    const stepZ = rayZ > 0 ? 1 : rayZ < 0 ? -1 : 0

    const deltaX = stepX / rayX
    const deltaY = stepY / rayY
    const deltaZ = stepZ / rayZ

    var maxX = floorX > ceilX ? floorX : ceilX
    var maxY = floorY > ceilY ? floorY : ceilY
    var maxZ = floorZ > ceilZ ? floorZ : ceilZ
    var axis = 0

    for i in 0..1000 {
      result.distance = maxX < maxY
        ? maxX < maxZ ? maxX : maxZ
        : maxY < maxZ ? maxY : maxZ

      if result.distance == maxX {
        result.cellX += stepX
        maxX += deltaX
        axis = 0
      }

      else if result.distance == maxY {
        result.cellY += stepY
        maxY += deltaY
        axis = 1
      }

      else {
        result.cellZ += stepZ
        maxZ += deltaZ
        axis = 2
      }

      if get(result.cellX, result.cellY, result.cellZ) != .EMPTY {
        if axis == 0 { result.normalX = -stepX }
        else if axis == 1 { result.normalY = -stepY }
        else { result.normalZ = -stepZ }
        return true
      }
    }

    return false
  }

  def loadFromFile(file DataArray) bool {
    for i in 0..FILE_HEADER.count {
      if file.byteOffset + 1 > file.byteCount { return false }
      if FILE_HEADER[i] != file.readByte { return false }
    }

    if file.byteOffset + 4 > file.byteCount { return false }
    var chunkCount = file.readInt
    if file.byteOffset + chunkCount * (4 * 3 + CHUNK_SIZE) > file.byteCount { return false }

    for chunk in _chunkList {
      chunk.free
    }

    _chunkMap = {}
    _chunkList = []

    while chunkCount > 0 {
      var originX = file.readInt << CELLS_SHIFT
      var originY = file.readInt << CELLS_SHIFT
      var originZ = file.readInt << CELLS_SHIFT
      if !_isValid(originX, originY, originZ) { return false }
      var chunk = Chunk.new(originX, originY, originZ)
      for i in 0..CHUNK_SIZE { chunk.cells[i] = file.readByte }
      _chunkMap[_key(originX, originY, originZ)] = chunk
      _chunkList.append(chunk)
      chunkCount--
    }

    return true
  }

  def saveToFile DataArray {
    var array = DataArray.new
    var chunkCount = 0

    for chunk in _chunkList {
      if !chunk.isEmpty {
        chunkCount++
      }
    }

    for i in 0..FILE_HEADER.count {
      array.appendByte(FILE_HEADER[i])
    }

    array.appendInt(chunkCount)

    for chunk in _chunkList {
      if !chunk.isEmpty {
        array.appendInt(chunk.originX >> CELLS_SHIFT)
        array.appendInt(chunk.originY >> CELLS_SHIFT)
        array.appendInt(chunk.originZ >> CELLS_SHIFT)

        for i in 0..CHUNK_SIZE {
          array.appendByte(chunk.cells[i])
        }
      }
    }

    return array
  }
}

namespace Voxels {
  const FILE_HEADER = "webglvrlevel\x01\0\0\0"
  const _vertices = DataArray.new
  const _temp = Vector3.new

  # Each chunk has a CELLS_SIZE * CELLS_SIZE * CELLS_SIZE block of cells
  const CELLS_SHIFT = 3
  const CELLS_SIZE = 1 << CELLS_SHIFT
  const CELLS_MASK = (1 << CELLS_SHIFT) - 1
  const CHUNK_SIZE = CELLS_SIZE * CELLS_SIZE * CELLS_SIZE

  # Chunk coordinates fit in a 32-bit integer (1 in chunk coordinates corresponds to CELLS_SIZE in cell coordinates)
  const CHUNK_BITS_X = 11
  const CHUNK_BITS_Y = 10
  const CHUNK_BITS_Z = 11
  const CHUNK_MASK_X = (1 << CHUNK_BITS_X) - 1
  const CHUNK_MASK_Y = (1 << CHUNK_BITS_Y) - 1
  const CHUNK_MASK_Z = (1 << CHUNK_BITS_Z) - 1

  def _isValid(cellX int, cellY int, cellZ int) bool {
    return
      cellX == (cellX << (32 - CHUNK_BITS_X - CELLS_SHIFT) >> (32 - CHUNK_BITS_X - CELLS_SHIFT)) &&
      cellY == (cellY << (32 - CHUNK_BITS_Y - CELLS_SHIFT) >> (32 - CHUNK_BITS_Y - CELLS_SHIFT)) &&
      cellZ == (cellZ << (32 - CHUNK_BITS_Z - CELLS_SHIFT) >> (32 - CHUNK_BITS_Z - CELLS_SHIFT))
  }

  def _key(cellX int, cellY int, cellZ int) int {
    assert(_isValid(cellX, cellY, cellZ))
    return
      (cellX >> CELLS_SHIFT & CHUNK_MASK_X) |
      (cellY >> CELLS_SHIFT & CHUNK_MASK_Y) << CHUNK_BITS_X |
      (cellZ >> CELLS_SHIFT & CHUNK_MASK_Z) << (CHUNK_BITS_X + CHUNK_BITS_Y)
  }

  enum AreaMode {
    DENSE
    SPARSE
  }

  class Chunk {
    const originX int
    const originY int
    const originZ int
    const cells = Uint8Array.new(CHUNK_SIZE)

    var distanceToEye = 0.0 # Filled out during rendering
    var _cachedDenseArea GPU.BufferArea = null
    var _cachedSparseArea GPU.BufferArea = null

    def centerX double { return originX + CELLS_SIZE * 0.5 }
    def centerY double { return originY + CELLS_SIZE * 0.5 }
    def centerZ double { return originZ + CELLS_SIZE * 0.5 }

    def get(localX int, localY int, localZ int) Cell {
      assert(0 <= localX && localX < CELLS_SIZE)
      assert(0 <= localY && localY < CELLS_SIZE)
      assert(0 <= localZ && localZ < CELLS_SIZE)
      return cells[localX | localY << CELLS_SHIFT | localZ << 2 * CELLS_SHIFT] as Cell
    }

    def set(localX int, localY int, localZ int, cell Cell) {
      assert(0 <= localX && localX < CELLS_SIZE)
      assert(0 <= localY && localY < CELLS_SIZE)
      assert(0 <= localZ && localZ < CELLS_SIZE)
      var index = localX | localY << CELLS_SHIFT | localZ << 2 * CELLS_SHIFT

      if cells[index] == cell {
        return
      }

      free
      cells[index] = cell
    }

    def isEmpty bool {
      for i in 0..CHUNK_SIZE {
        if cells[i] as Cell != .EMPTY {
          return false
        }
      }
      return true
    }

    def free {
      _cachedDenseArea?.free
      _cachedSparseArea?.free

      _cachedDenseArea = null
      _cachedSparseArea = null
    }

    def denseArea(pool GPU.BufferPool) GPU.BufferArea {
      _cachedDenseArea ?= _generateArea(pool, .DENSE)
      return _cachedDenseArea
    }

    def sparseArea(pool GPU.BufferPool) GPU.BufferArea {
      _cachedSparseArea ?= _generateArea(pool, .SPARSE)
      return _cachedSparseArea
    }

    def _generateArea(pool GPU.BufferPool, mode AreaMode) GPU.BufferArea {
      _vertices.clear

      var originX = self.originX
      var originY = self.originY
      var originZ = self.originZ
      var cells = self.cells

      # Make sure to create quads front-to-back to take maximal advantage of
      # high-z. Do the y axis first because players will be mostly looking down.

      # -y
      for y in 0..CELLS_SIZE {
        for x in 0..CELLS_SIZE {
          for z in 0..CELLS_SIZE {
            const cell = cells[x | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell
            if cell != .EMPTY && (mode == .DENSE || y == 0 || cells[x | (y - 1) << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell == .EMPTY) {
              _appendQuad(
                originX + x, originY + y, originZ + z,
                originX + x + 0.5, originY + y + 0.5, originZ + z + 0.5,
                .X, .Z, cell)
            }
          }
        }
      }

      # +y
      for y_inv in 0..CELLS_SIZE {
        const y = y_inv ^ CELLS_MASK
        for x in 0..CELLS_SIZE {
          for z in 0..CELLS_SIZE {
            const cell = cells[x | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell
            if cell != .EMPTY && (mode == .DENSE || y == CELLS_MASK || cells[x | (y + 1) << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell == .EMPTY) {
              _appendQuad(
                originX + x, originY + 1 + y, originZ + z,
                originX + x + 0.5, originY + y + 0.5, originZ + z + 0.5,
                .Z, .X, cell)
            }
          }
        }
      }

      # -x
      for x in 0..CELLS_SIZE {
        for y in 0..CELLS_SIZE {
          for z in 0..CELLS_SIZE {
            const cell = cells[x | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell
            if cell != .EMPTY && (mode == .DENSE || x == 0 || cells[(x - 1) | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell == .EMPTY) {
              _appendQuad(
                originX + x, originY + y, originZ + z,
                originX + x + 0.5, originY + y + 0.5, originZ + z + 0.5,
                .Z, .Y, cell)
            }
          }
        }
      }

      # +x
      for x_inv in 0..CELLS_SIZE {
        const x = x_inv ^ CELLS_MASK
        for y in 0..CELLS_SIZE {
          for z in 0..CELLS_SIZE {
            const cell = cells[x | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell
            if cell != .EMPTY && (mode == .DENSE || x == CELLS_MASK || cells[(x + 1) | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell == .EMPTY) {
              _appendQuad(
                originX + x + 1, originY + y, originZ + z,
                originX + x + 0.5, originY + y + 0.5, originZ + z + 0.5,
                .Y, .Z, cell)
            }
          }
        }
      }

      # -z
      for z in 0..CELLS_SIZE {
        for x in 0..CELLS_SIZE {
          for y in 0..CELLS_SIZE {
            const cell = cells[x | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell
            if cell != .EMPTY && (mode == .DENSE || z == 0 || cells[x | y << CELLS_SHIFT | (z - 1) << 2 * CELLS_SHIFT] as Cell == .EMPTY) {
              _appendQuad(
                originX + x, originY + y, originZ + z,
                originX + x + 0.5, originY + y + 0.5, originZ + z + 0.5,
                .Y, .X, cell)
            }
          }
        }
      }

      # +z
      for z_inv in 0..CELLS_SIZE {
        const z = z_inv ^ CELLS_MASK
        for x in 0..CELLS_SIZE {
          for y in 0..CELLS_SIZE {
            const cell = cells[x | y << CELLS_SHIFT | z << 2 * CELLS_SHIFT] as Cell
            if cell != .EMPTY && (mode == .DENSE || z == CELLS_MASK || cells[x | y << CELLS_SHIFT | (z + 1) << 2 * CELLS_SHIFT] as Cell == .EMPTY) {
              _appendQuad(
                originX + x, originY + y, originZ + 1 + z,
                originX + x + 0.5, originY + y + 0.5, originZ + z + 0.5,
                .X, .Y, cell)
            }
          }
        }
      }

      return pool.allocate(GPU.VertexFormat.POSITION_F3_CENTER_F3_COLOR_B4, _vertices.bytes)
    }

    def _packUV(s int, t int, cell Cell, ds int, dt int) {
      _vertices.appendColor(Color.new(
        ((s % 3 + 3) % 3 + ds) * 0x55,
        ((t % 3 + 3) % 3 + dt) * 0x55,
        cell, 0))
    }

    def _appendQuad(x int, y int, z int, cx double, cy double, cz double, u Delta, v Delta, cell Cell) {
      const ux = x + u.x
      const uy = y + u.y
      const uz = z + u.z

      const vx = x + v.x
      const vy = y + v.y
      const vz = z + v.z

      const uvx = ux + vx - x
      const uvy = uy + vy - y
      const uvz = uz + vz - z

      const s = x * u.x + y * u.y + z * u.z
      const t = x * v.x + y * v.y + z * v.z

      _vertices.appendFloat(x)
      _vertices.appendFloat(y)
      _vertices.appendFloat(z)
      _vertices.appendFloat(cx)
      _vertices.appendFloat(cy)
      _vertices.appendFloat(cz)
      _packUV(s, t, cell, 0, 0)

      _vertices.appendFloat(ux)
      _vertices.appendFloat(uy)
      _vertices.appendFloat(uz)
      _vertices.appendFloat(cx)
      _vertices.appendFloat(cy)
      _vertices.appendFloat(cz)
      _packUV(s, t, cell, 1, 0)

      _vertices.appendFloat(uvx)
      _vertices.appendFloat(uvy)
      _vertices.appendFloat(uvz)
      _vertices.appendFloat(cx)
      _vertices.appendFloat(cy)
      _vertices.appendFloat(cz)
      _packUV(s, t, cell, 1, 1)

      _vertices.appendFloat(x)
      _vertices.appendFloat(y)
      _vertices.appendFloat(z)
      _vertices.appendFloat(cx)
      _vertices.appendFloat(cy)
      _vertices.appendFloat(cz)
      _packUV(s, t, cell, 0, 0)

      _vertices.appendFloat(uvx)
      _vertices.appendFloat(uvy)
      _vertices.appendFloat(uvz)
      _vertices.appendFloat(cx)
      _vertices.appendFloat(cy)
      _vertices.appendFloat(cz)
      _packUV(s, t, cell, 1, 1)

      _vertices.appendFloat(vx)
      _vertices.appendFloat(vy)
      _vertices.appendFloat(vz)
      _vertices.appendFloat(cx)
      _vertices.appendFloat(cy)
      _vertices.appendFloat(cz)
      _packUV(s, t, cell, 0, 1)
    }
  }

  type Delta : int {
    def x int {
      return self as int & 1
    }

    def y int {
      return self as int >> 1 & 1
    }

    def z int {
      return self as int >> 2
    }
  }

  namespace Delta {
    const X = new(1, 0, 0)
    const Y = new(0, 1, 0)
    const Z = new(0, 0, 1)

    def new(x int, y int, z int) Delta {
      assert(x == 0 || x == 1)
      assert(y == 0 || y == 1)
      assert(z == 0 || z == 1)
      return (x | y << 1 | z << 2) as Delta
    }
  }
}
